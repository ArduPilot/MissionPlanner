{"version":3,"file":"OrientedBoundingBox-50aabd84.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  var i;\n  var length = positions.length;\n\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  var invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  var center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  var scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nvar scratchOffset = new Cartesian3();\nvar scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  var halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  var centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  var scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  var center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nvar scratchRectangleCenterCartographic = new Cartographic();\nvar scratchRectangleCenter = new Cartesian3();\nvar scratchPerimeterCartographicNC = new Cartographic();\nvar scratchPerimeterCartographicNW = new Cartographic();\nvar scratchPerimeterCartographicCW = new Cartographic();\nvar scratchPerimeterCartographicSW = new Cartographic();\nvar scratchPerimeterCartographicSC = new Cartographic();\nvar scratchPerimeterCartesianNC = new Cartesian3();\nvar scratchPerimeterCartesianNW = new Cartesian3();\nvar scratchPerimeterCartesianCW = new Cartesian3();\nvar scratchPerimeterCartesianSW = new Cartesian3();\nvar scratchPerimeterCartesianSC = new Cartesian3();\nvar scratchPerimeterProjectedNC = new Cartesian2();\nvar scratchPerimeterProjectedNW = new Cartesian2();\nvar scratchPerimeterProjectedCW = new Cartesian2();\nvar scratchPerimeterProjectedSW = new Cartesian2();\nvar scratchPerimeterProjectedSC = new Cartesian2();\n\nvar scratchPlaneOrigin = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlaneXAxis = new Cartesian3();\nvar scratchHorizonCartesian = new Cartesian3();\nvar scratchHorizonProjected = new Cartesian2();\nvar scratchMaxY = new Cartesian3();\nvar scratchMinY = new Cartesian3();\nvar scratchZ = new Cartesian3();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    var tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    var tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    var lonCenter = tangentPointCartographic.longitude;\n    var latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    var perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    var perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    var perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    var perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    var perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  var fullyAboveEquator = rectangle.south > 0.0;\n  var fullyBelowEquator = rectangle.north < 0.0;\n  var latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  var centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  var planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  var isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  var planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  var planeYAxis = Cartesian3.UNIT_Z;\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  var horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  var farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var center = box.center;\n  var normal = plane.normal;\n  var halfAxes = box.halfAxes;\n  var normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  var radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nvar scratchCartesianU = new Cartesian3();\nvar scratchCartesianV = new Cartesian3();\nvar scratchCartesianW = new Cartesian3();\nvar scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  var uHalf = Cartesian3.magnitude(u);\n  var vHalf = Cartesian3.magnitude(v);\n  var wHalf = Cartesian3.magnitude(w);\n\n  Cartesian3.normalize(u, u);\n  Cartesian3.normalize(v, v);\n  Cartesian3.normalize(w, w);\n\n  var pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  var distanceSquared = 0.0;\n  var d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nvar scratchCorner = new Cartesian3();\nvar scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var minDist = Number.POSITIVE_INFINITY;\n  var maxDist = Number.NEGATIVE_INFINITY;\n\n  var center = box.center;\n  var halfAxes = box.halfAxes;\n\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  var corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nvar scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"names":["Cartesian3","defaultValue","Matrix3","Check","defined","DeveloperError","Cartographic","Cartesian2","Plane","CesiumMath","Ellipsoid","Rectangle","EllipsoidTangentPlane","Intersect","Interval","BoundingSphere"],"mappings":"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"}