{"category": 2, "kind": 1, "get_min_bitlen": {}, "default_dtid": 1, "get_max_bitlen": {}, "union": false, "fields": [{"type": {"category": 0, "kind": 1, "full_name": "saturated uint7", "cast_mode": 0, "value_range": [0, 127], "bitlen": 7}, "name": "node_id"}, {"type": {"category": 0, "kind": 0, "full_name": "saturated bool", "cast_mode": 0, "value_range": [0, 1], "bitlen": 1}, "name": "first_part_of_unique_id"}, {"type": {"full_name": "saturated uint8[<=16]", "category": 1, "value_type": {"category": 0, "kind": 1, "full_name": "saturated uint8", "cast_mode": 0, "value_range": [0, 255], "bitlen": 8}, "mode": 1, "max_size": 16}, "name": "unique_id"}], "_data_type_signature": null, "version": null, "source_text": "#\n# This message is used for dynamic Node ID allocation.\n#\n# When a node needs to request a node ID dynamically, it will transmit an anonymous message transfer of this type.\n# In order to reduce probability of CAN ID collisions when multiple nodes are publishing this request, the CAN ID\n# field of anonymous message transfer includes a Discriminator, which is a special field that has to be filled with\n# random data by the transmitting node. Since Discriminator collisions are likely to happen (probability approx.\n# 0.006%), nodes that are requesting dynamic allocations need to be able to handle them correctly. Hence, a collision\n# resolution protocol is defined (alike CSMA/CD). The collision resolution protocol is based on two randomized\n# transmission intervals:\n#\n# - Request period - Trequest.\n# - Followup delay - Tfollowup.\n#\n# Recommended randomization ranges for these intervals are documented in the costants of this message type (see below).\n# Random intervals must be chosen anew per transmission, whereas the Discriminator value is allowed to stay constant\n# per node.\n#\n# In the below description the following terms are used:\n# - Allocator - the node that serves allocation requests.\n# - Allocatee - the node that requests an allocation from the Allocator.\n#\n# The response timeout is not explicitly defined for this protocol, as the Allocatee will request the allocation\n# Trequest units of time later again, unless the allocation has been granted. Despite this, the implementation can\n# consider the value of FOLLOWUP_TIMEOUT_MS as an allocation timeout, if necessary.\n#\n# On the allocatee's side the protocol is defined through the following set of rules:\n#\n# Rule A. On initialization:\n# 1. The allocatee subscribes to this message.\n# 2. The allocatee starts the Request Timer with a random interval of Trequest.\n#\n# Rule B. On expiration of Request Timer:\n# 1. Request Timer restarts with a random interval of Trequest.\n# 2. The allocatee broadcasts a first-stage Allocation request message, where the fields are assigned following values:\n#    node_id                 - preferred node ID, or zero if the allocatee doesn't have any preference\n#    first_part_of_unique_id - true\n#    unique_id               - first MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of unique ID\n#\n# Rule C. On any Allocation message, even if other rules also match:\n# 1. Request Timer restarts with a random interval of Trequest.\n#\n# Rule D. On an Allocation message WHERE (source node ID is non-anonymous) AND (allocatee's unique ID starts with the\n# bytes available in the field unique_id) AND (unique_id is less than 16 bytes long):\n# 1. The allocatee waits for Tfollowup units of time, while listening for other Allocation messages. If an Allocation\n#    message is received during this time, the execution of this rule will be terminated. Also see rule C.\n# 2. The allocatee broadcasts a second-stage Allocation request message, where the fields are assigned following values:\n#    node_id                 - same value as in the first-stage\n#    first_part_of_unique_id - false\n#    unique_id               - at most MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of local unique ID with an offset\n#                              equal to number of bytes in the received unique ID\n#\n# Rule E. On an Allocation message WHERE (source node ID is non-anonymous) AND (unique_id fully matches allocatee's\n# unique ID) AND (node_id in the received message is not zero):\n# 1. Request Timer stops.\n# 2. The allocatee initializes its node_id with the received value.\n# 3. The allocatee terminates subscription to Allocation messages.\n# 4. Exit.\n#\n\n#\n# Recommended randomization range for request period.\n#\n# These definitions have an advisory status; it is OK to pick higher values for both bounds, as it won't affect\n# protocol compatibility. In fact, it is advised to pick higher values if the target application is not concerned\n# about the time it will spend on completing the dynamic node ID allocation procedure, as it will reduce\n# interference with other nodes, possibly of higher importance.\n#\n# The lower bound shall not be lower than FOLLOWUP_TIMEOUT_MS, otherwise the request may conflict with a followup.\n#\nuint16 MAX_REQUEST_PERIOD_MS = 1000     # It is OK to exceed this value\nuint16 MIN_REQUEST_PERIOD_MS = 600      # It is OK to exceed this value\n\n#\n# Recommended randomization range for followup delay.\n# The upper bound shall not exceed FOLLOWUP_TIMEOUT_MS, because the allocator will reset the state on its end.\n#\nuint16 MAX_FOLLOWUP_DELAY_MS = 400\nuint16 MIN_FOLLOWUP_DELAY_MS = 0        # Defined only for regularity; will always be zero.\n\n#\n# Allocator will reset its state if there was no follow-up request in this amount of time.\n#\nuint16 FOLLOWUP_TIMEOUT_MS = 500\n\n#\n# Any request message can accommodate no more than this number of bytes of unique ID.\n# This limitation is needed to ensure that all request transfers are single-frame.\n# This limitation does not apply to CAN FD transport.\n#\nuint8 MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST = 6\n\n#\n# When requesting an allocation, set the field 'node_id' to this value if there's no preference.\n#\nuint7 ANY_NODE_ID = 0\n\n#\n# If transfer is anonymous, this is the preferred ID.\n# If transfer is non-anonymous, this is allocated ID.\n#\n# If the allocatee does not have any preference, this value must be set to zero. In this case, the allocator\n# must choose the highest unused node ID value for this allocation (except 126 and 127, that are reserved for\n# network maintenance tools). E.g., if the allocation table is empty and the node has requested an allocation\n# without any preference, the allocator will grant the node ID 125.\n#\n# If the preferred node ID is not zero, the allocator will traverse the allocation table starting from the\n# prefferred node ID upward, untill a free node ID is found. If a free node ID could not be found, the\n# allocator will restart the search from the preferred node ID downward, until a free node ID is found.\n#\n# In pseudocode:\n#   int findFreeNodeID(const int preferred)\n#   {\n#       // Search up\n#       int candidate = (preferred > 0) ? preferred : 125;\n#       while (candidate <= 125)\n#       {\n#           if (!isOccupied(candidate))\n#               return candidate;\n#           candidate++;\n#       }\n#       // Search down\n#       candidate = (preferred > 0) ? preferred : 125;\n#       while (candidate > 0)\n#       {\n#           if (!isOccupied(candidate))\n#               return candidate;\n#           candidate--;\n#       }\n#       // Not found\n#       return -1;\n#   }\n#\nuint7 node_id\n\n#\n# If transfer is anonymous, this field indicates first-stage request.\n# If transfer is non-anonymous, this field should be assigned zero and ignored.\n#\nbool first_part_of_unique_id\n\n#\n# If transfer is anonymous, this array must not contain more than MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST items.\n# Note that array is tail-optimized, i.e. it will not be prepended with length field.\n#\nuint8[<=16] unique_id\n", "full_name": "uavcan.protocol.dynamic_node_id.Allocation", "source_file": "C:\\Users\\michael\\Source\\Repos\\MissionPlanner\\ExtLibs\\UAVCAN\\dsdl\\uavcan\\protocol\\dynamic_node_id\\1.Allocation.uavcan", "constants": [{"init_expression": "1000", "type": {"category": 0, "kind": 1, "full_name": "saturated uint16", "cast_mode": 0, "value_range": [0, 65535], "bitlen": 16}, "name": "MAX_REQUEST_PERIOD_MS", "value": 1000, "string_value": "1000"}, {"init_expression": "600", "type": {"category": 0, "kind": 1, "full_name": "saturated uint16", "cast_mode": 0, "value_range": [0, 65535], "bitlen": 16}, "name": "MIN_REQUEST_PERIOD_MS", "value": 600, "string_value": "600"}, {"init_expression": "400", "type": {"category": 0, "kind": 1, "full_name": "saturated uint16", "cast_mode": 0, "value_range": [0, 65535], "bitlen": 16}, "name": "MAX_FOLLOWUP_DELAY_MS", "value": 400, "string_value": "400"}, {"init_expression": "0", "type": {"category": 0, "kind": 1, "full_name": "saturated uint16", "cast_mode": 0, "value_range": [0, 65535], "bitlen": 16}, "name": "MIN_FOLLOWUP_DELAY_MS", "value": 0, "string_value": "0"}, {"init_expression": "500", "type": {"category": 0, "kind": 1, "full_name": "saturated uint16", "cast_mode": 0, "value_range": [0, 65535], "bitlen": 16}, "name": "FOLLOWUP_TIMEOUT_MS", "value": 500, "string_value": "500"}, {"init_expression": "6", "type": {"category": 0, "kind": 1, "full_name": "saturated uint8", "cast_mode": 0, "value_range": [0, 255], "bitlen": 8}, "name": "MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST", "value": 6, "string_value": "6"}, {"init_expression": "0", "type": {"category": 0, "kind": 1, "full_name": "saturated uint7", "cast_mode": 0, "value_range": [0, 127], "bitlen": 7}, "name": "ANY_NODE_ID", "value": 0, "string_value": "0"}]}